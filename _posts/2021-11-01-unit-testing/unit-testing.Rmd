---
title: "Getting started with unit testing in R"
description: |
  tbd
base_url: https://www.pipinghotdata.com/
twitter:
  site: "@PipingHotData"
  creator: "@PipingHotData"
author:
  - name: Shannon Pileggi
date: 11-01-2021
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    self_contained: false
draft: false
creative_commons: CC BY
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

```{r, echo = FALSE}
folder <- "2021-11-01-unit-testing"
```

# TL;DR

This blog post accompanies the R-Ladies Philly workshop on Nov 11, 2021 ([recording on YouTube](https://youtu.be/4bPekjzIYiU){target=_blank_}), where we live coded use of the
`usethis`, `devtools`, `testthat`, and `covr` packages to automate R package testing.
This post complements the recording through highlighting key points, rather than 
listing all actions.

# Abstract

In this workshop, Shannon Pileggi and Gordon Shotwell discuss how to get started with unit testing in R, which is formal automated testing of functions within packages. We demonstrate handy functions in `usethis` and `devtools`, strategies for writing tests, debugging techniques, and broad concepts in function writing that facilitate a smoother testing process.

This workshop picks up exactly where we left our little `ralph` (aka **R**-**L**adies **Ph**illy) package one year ago with [“Your first R package in 1 hour: Tools that make R package development easy”](https://www.pipinghotdata.com/posts/2020-10-25-your-first-r-package-in-1-hour/){target="_blank"}. Participants will get the most out of this workshop if they review those materials in advance, or if they are already familiar with building R packages with `devtools` and `usethis`.


# Packages

This material was developed using:

| Software / package  | Version               |
|---------------------|-----------------------|
| R                   | 4.1.1                 | 
| RStudio             | 351 "Ghost Orchid"    |
| `usethis`           | 2.1.2                 |
| `devtools`          | 2.4.2                 |
| `testthat`          | 3.1.0                 |
| `covr`              | 3.5.1                 |
| `broom`             | 0.7.9                 |
| `glue`              | 1.4.2                 |
| `magrittr`          | 2.0.1                 |
| `purrr`             | 0.3.4                 |
| `rlang`             | 0.4.12                |


# Tool kit

This table contains the general process functions used in this workshop. Single usage f
unctions only need to be used one time in the development process; multiple usage functions
are executed as needed. 


| Usage    | Function                                       | Purpose                           |
|----------|------------------------------------------------|-----------------------------------|
| Single   | `usethis::use_testthat()`                      | initialize testing infrastructure | 
| Multiple | `usethis::use_test()`                          | create a new test file            |
|          | `devtools::test()`                             | execute and evaluate all tests in package |
|          | `covr::report()`                               | reports test coverage |
|          | `browser()`                                    | debugging: interrupt and inspect function execution |
|          | `devtools::check()`                            | build package locally and check   |
|          | `devtools::load_all()`                         | load functions in `r emo::ji("folder")` `R/` into memory    |
|          | `usethis::use_r("function")`                   | create R script for function      |
|          | `usethis::use_package("package")     `         | add package dependency            |
|          | `devtools::document()`                         | build and add documentation       |

Other resources:

* R package developement [cheat sheet](https://rklopotek.blog.uksw.edu.pl/files/2017/09/package-development.pdf){target="_blank"}

* [Ch. 12 Testing](https://r-pkgs.org/tests.html){target="_blank"} in R packages by Hadley Wickham and Jenny Bryan

* [Ch. 8.2 Signalling conditions](https://adv-r.hadley.nz/conditions.html#signalling-conditions){target="_blank"} in Advanced R by  Hadley Wickham

* [testthat](https://testthat.r-lib.org/){target="_blank"} package documentation

* {usethis} [user interface functions](https://usethis.r-lib.org/reference/ui.html){target="_blank"}

* [covr](https://covr.r-lib.org/){target="_blank"} package documentation

* [Building tidy tools workshop](https://github.com/hadley/tidy-tools){target="_blank"} at `rstudio::conf(2019)` by Hadley Wickham and Charlotte Wickham

* Debugging
   
   + RStudio blog post by Jonathan McPherson [Debugging with the RStudio IDE](https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE){target="_blank"}
   
   + [Ch 22 Debugging](https://adv-r.hadley.nz/debugging.html){target="_blank"} in Advanced R by  Hadley Wickham

* Indrajeet Patil's curated list of [awesome tools to assist R package development](https://indrajeetpatil.github.io/awesome-r-pkgtools/){target="_blank"}.

# Why unit test

If you write R functions, then you already test your code. You write a function, 
see if it works, and iterate on the function until you
achieve your desired result. In the package development work flow, it looks 
something like this:

```{r original-process, eval=TRUE, echo=FALSE}
#| fig.cap: > 
#|   Workflow cycle of function development without automated testing, from
#|   2019 Building Tidy Tools workshop.
#| fig.alt: >
#|   Circle with three blocks: Modify code, reload code (`load_all()`), and
#|   explore in console.  
knitr::include_graphics("img/tidy-tools-workflow-no-unit-testing.PNG")
```

This process is where most of us likely start, and possibly even stay for a while.
But it can be tedious, time consuming, and error-prone to manually check
all possible combinations of function inputs and arguments.

Instead, we can _automate_ tests with `testthat` in a new workflow.

```{r test-process-1, eval=TRUE, echo=FALSE}
#| fig.cap: > 
#|   Workflow cycle of function development when getting started with
#|   automated testing, from 2019 Building Tidy Tools workshop.
#| fig.alt: >
#|   Circle with three blocks: Modify code, reload code (`load_all()`), and
#|   run automated tests (`test()`).  
knitr::include_graphics("img/tidy-tools-workflow-testing-1.PNG")
```

And once you trust and get comfortable with the tests you have set up, you can
speed up the development process even more by removing the loading code step.

```{r test-process-2, eval=TRUE, echo=FALSE}
#| fig.cap: > 
#|   Workflow cycle of function development when comfortable with
#|   automated testing, from 2019 Building Tidy Tools workshop.
#| fig.alt: >
#|   Circle with two blocks: Modify code and
#|   run automated tests (`test()`).  
knitr::include_graphics("img/tidy-tools-workflow-testing-2.PNG")
```

Like anything in programming, there is an up-front time investment in learning
this framework and process, but with significant downstream time savings.

# Getting started

This post picks up exactly where we left the `ralph` package in [Your first R package in 1 hour](https://www.pipinghotdata.com/posts/2020-10-25-your-first-r-package-in-1-hour/#tl-dr){target=_blank_} in November 2020. In order to keep that as a stand-alone resource, I
created a second repo called `ralphGetsTested` for this workshop, which was a copy of `ralph` as we left it.

1. If you want to follow along with the unit testing steps and practice yourself, fork and clone the [`ralph`](https://github.com/shannonpileggi/ralph){target=_blank_} repo.

`usethis::create_from_github("shannonpileggi/ralph")`

2. If you want to see the repository as it stood at the conclusion of the unit testing workshop, fork and clone [`ralphGetsTested`](https://github.com/shannonpileggi/ralphGetsTested){target=_blank_} repo.

`usethis::create_from_github("shannonpileggi/ralphGetsTested")`

# Keyboard shortcuts


* `Ctrl + S` for save file

* `Ctrl + Shift + L` for `devtools::load_all()`

* `Ctrl + Shift + F10` to restart R

* `Ctrl + Shift + T` for `devtools::test()`

* Native language

* Thank Gordon

* What is unit testing / why do it?

* Presenters experience with unit testing

* Attendees experience with unit testing.

# Notes

* `devtools::check()` confirm error free

* `devtools::load_all()` command shift L

* ?compute_corr

* `compute_corr(data = faithful, var1 = eruptions, var2 = waiting)`

* review function

* `usethis::use_testthat()` to create overall testing infrastructure - ONE TIME

* `usethis::use_test("compute_corr")` to create a new test file

   + WHAT TO NAME THIS FILE? - same as function name
   
   + WHAT TO NAME TESTS IN THIS FILE?
   
    + It can be whatever also the name can have spaces. It's just something that tells you what failed when the test fails
    
    + So there's no right name, it's just something that reminds future you where the failing test is
  
   
* tests define correctness for your code - what do i care that is right?

* higher risk would do more tests

* to run tests `devtools::test()`

* run tests button runs test in fresh environment; devtools test in global environment

* browser() in function for troubleshooting

* `covr::report` percent of code covered

   + restart R, then run

   + THIS ISNT WORKING
   
   + `covr::report`

* put `browser()` in function for debugging - NOT IN A PIPE

* to test variables in input data set, create a message/warning & test for that message/warning

* Restart R -> cntrl + shift + F10

# Testing code

To enter one at a time.

```{r, eval = FALSE}
test_that("length", {
  expected <- compute_corr(data = faithful, var1 = eruptions, var2 = waiting)
  expect_s3_class(expected, "data.frame")
  expect_equal(dim(expected), c(1,2))
  expect_named(expected, c("correlation", "pval"))
  # can run without tolerance
  expect_equal(expected[["correlation"]], 0.901, tolerance = 0.001)
})
```

Correction to add to `compute_corr` for `expect_equal` to pass:

```{r, eval = FALSE}
# remove attribute name from results
attr(results$correlation, "names") <- NULL
```


# Distinguishing message/warning/error:

https://adv-r.hadley.nz/conditions.html#signalling-conditions

Error to add to `compute_corr` to evaluate inputs:

Errors are the most severe; they indicate that there is no way for a function to continue and execution must stop.

Warnings fall somewhat in between errors and message, and typically indicate that something has gone wrong but the function has been able to at least partially recover.

Messages are the mildest; they are way of informing users that some action has been performed on their behalf.


```{r}
stop("This is what an error looks like")
#> Error in eval(expr, envir, enclos): This is what an error looks like

warning("This is what a warning looks like")
#> Warning: This is what a warning looks like

message("This is what a message looks like")
#> This is what a message looks like
```


# checking variable names

Add to function body:

```{r, eval = FALSE}
  # convert variable names to character strings
  var1_chr <- rlang::as_label(rlang::ensym(var1))
  var2_chr <- rlang::as_label(rlang::ensym(var2))

  # alert user if variable not in data set ----
  if (!(var1_chr %in% names(data))){
    #stop(glue::glue("{var1_chr} not in data set."))
    usethis::ui_stop("{var1_chr} is not in the data set.")
  }

  # alert user if variable not in data set ----
  if (!(var2_chr %in% names(data))){
    #stop(glue::glue("{var2_chr} not in data set."))
    usethis::ui_stop("{var2_chr} is not in the data set.")
  }
```



Add to test

```{r, eval = FALSE}
test_that("length", {
  # evaluate correctness of output produced ----
  expected <- compute_corr(data = faithful, var1 = eruptions, var2 = waiting)
  expect_s3_class(expected, "data.frame")
  expect_equal(dim(expected), c(1,2))
  expect_named(expected, c("correlation", "pval"))
  expect_equal(expected[["correlation"]], 0.901, tolerance = 0.001)
  # catching errors ----
  expect_error(compute_corr(data = faithful, var1 = erruptions, var2 = waiting))
})

```


* `devtools::test()` passes

* `devtools::check()` has a warning

* `usethis::use_package("usethis")`

* `devtools::check()`




# Challenge function

* Can we break this up to make it easier to test?

* What type of object should the function output?

* What type of object does this function expect, can we put up guardrails so the user doesn't send the wrong thing? How do we test those guardrails?

## original

`usethis::use_r("awesome_rladies")`

```{r}
awesome_rladies <- function(v) {
  
  sapply(v, function(x) {
    if (x == 1) {
      verb <- "is"
      noun <- "RLady"
    }
    
    if (x > 1) {
      verb <- "are"
      noun <- "RLadies"
    }
    
    as.character(glue::glue("There {verb} {x} awesome {noun}!"))
  })
}
```


## broken up

```{r, eval = FALSE}
write_rladies <- function(x){
  if (x == 1) {
    verb <- "is"
    noun <- "RLady"
  } 
  
  if(x > 1) {
    verb <- "are"
    noun <- "RLadies"
  }
  
  as.character(glue::glue("There {verb} {x} awesome {noun}!"))
}




compose_rladies <- function(x){
  #sapply(x, write_rladies)
  purrr::map_chr(x, write_rladies)
}
```


 `usethis::use_test()` to create a second test file, right?
 
## tests

```{r}
usethis::use_test("awesome_rladies")
```


what to name test?

```{r}
test_that("assess-awesome_rladies", {
  # evaluate output produced ----
  expected <- write_rladies(1)
  expect_type(expected, "character")
})

```



add to function

```{r, eval = FALSE}
write_rladies <- function(x){
  
 if ( !(is.numeric(x) & (x >= 1)) ){
    usethis::ui_stop("Input must be numeric and greater than or equal to 1.")
  }

  
  if (x == 1) {
    verb <- "is"
    noun <- "RLady"
  } 
  
  if(x > 1) {
    verb <- "are"
    noun <- "RLadies"
  }
  
  glue::glue("There {verb} {x} awesome {noun}!")
}
```

add to test, need to work through this more



```{r}
test_that("correct", {
  # evaluate output produced ----
  expected_1 <- write_rladies(1)
  expected_2 <- write_rladies(2)
  expect_type(expected_1, "character")
  expect_equal(expected_1, "There is 1 awesome RLady!")
  expect_equal(expected_2, "There are 2 awesome RLadies!")
  # ----
  expected_multiple <- compose_rladies(1:2)
  expect_length(expected_multiple, 2)
  # catching errors ----
  expect_error(compose_rladies("a"))
  expect_error(compose_rladies(0))
})

```

# testthat 3e

* [https://testthat.r-lib.org/articles/third-edition.html](https://testthat.r-lib.org/articles/third-edition.html)

* the checking is a bit different from regular testthat (uses waldo package), and the tests run in parallel (so much faster)

* use first edition if nothing is specified; add this to your DESCRIPTION file

```
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.1.2
Config/testthat/edition: 3
Config/testthat/parallel: true
```

* gtsummary check went from 40 min to 14 min