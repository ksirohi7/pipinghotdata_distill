---
title: "Getting started with unit testing in R"
description: |
  tbd
base_url: https://www.pipinghotdata.com/
twitter:
  site: "@PipingHotData"
  creator: "@PipingHotData"
author:
  - name: Shannon Pileggi
date: 11-01-2021
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    self_contained: false
draft: false
creative_commons: CC BY
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# TL;DR

# Abstract

In this workshop, Shannon Pileggi and Gordon Shotwell discuss how to get started with unit testing in R, which is formal automated testing of functions within packages. We demonstrate handy functions in `usethis` and `devtools`, strategies for writing tests, debugging techniques, and broad concepts in function writing that facilitate a smoother testing process.

This workshop picks up exactly where we left our little `ralph` (aka **R**-**L**adies **Ph**illy) package one year ago with [“Your first R package in 1 hour: Tools that make R package development easy”](https://www.pipinghotdata.com/posts/2020-10-25-your-first-r-package-in-1-hour/){target="_blank"}. Participants will get the most out of this workshop if they review those materials in advance, or if they are already familiar with building R packages with `devtools` and `usethis`.




# Packages

This material was developed using:

| Software / package  | Version               |
|---------------------|-----------------------|
| R                   | 4.1.1                 | 
| RStudio             | 351 "Ghost Orchid"    |
| `usethis`           | 2.1.2                 |
| `devtools`          | 2.4.2                 |
| `testthat`          | 3.1.0                 |
| `broom`             | 0.7.9                 |

# Getting started

You can work either (1) locally or (2) with GitHub.

1. To work locally, click the green `Code` button and download the zipped `ralphGetsTested` repository.

2. To work through GitHub, fork and clone this repository with
`usethis::create_from_github("shannonpileggi/ralphGetsTested")`.

# Notes

* `devtools::load_all()` command shift L

* `usethis::use_testthat()` to create overall testing infrastructure

* `usethis::use_test()` to create a new test file

   + WHAT TO NAME THIS FILE? - same as function name
   
   + WHAT TO NAME TESTS IN THIS FILE?
   
* tests define correctness for your code - what do i care that is right?

* higher risk would do more tests

* to run tests `devtools::test()`

* run tests button runs test in fresh environment; devtools test in global environment

* browser() in function for troubleshooting

* `devtools::test_coverage()` percent of code covered

   + THIS ISNT WORKING
   
   + `covr::report`

* put `browser()` in function for debugging - NOT IN A PIPE

* to test variables in input data set, create a message/warning & test for that message/warning

* Restart R -> cntrl + shift + F10

# Testing code

To enter one at a time.

```{r, eval = FALSE}
test_that("length", {
  expected <- compute_corr(data = faithful, var1 = eruptions, var2 = waiting)
  expect_s3_class(expected, "data.frame")
  expect_equal(dim(expected), c(1,2))
  expect_named(expected, c("correlation", "pval"))
  # can run without tolerance
  expect_equal(expected[["correlation"]], 0.901, tolerance = 0.001)
})
```

Correction to add to `compute_corr` for `expect_equal` to pass:

```{r, eval = FALSE}
# remove attribute name from results
attr(results$correlation, "names") <- NULL
```


# Distinguishing message/warning/error:

https://adv-r.hadley.nz/conditions.html#signalling-conditions

Error to add to `compute_corr` to evaluate inputs:

Errors are the most severe; they indicate that there is no way for a function to continue and execution must stop.

Warnings fall somewhat in between errors and message, and typically indicate that something has gone wrong but the function has been able to at least partially recover.

Messages are the mildest; they are way of informing users that some action has been performed on their behalf.


```{r}
stop("This is what an error looks like")
#> Error in eval(expr, envir, enclos): This is what an error looks like

warning("This is what a warning looks like")
#> Warning: This is what a warning looks like

message("This is what a message looks like")
#> This is what a message looks like
```


# checking variable names

Add to function body:

```{r, eval = FALSE}
  # convert variable names to character strings
  var1_chr <- rlang::as_label(rlang::ensym(var1))
  var2_chr <- rlang::as_label(rlang::ensym(var2))

  # alert user if variable not in data set ----
  if (!(var1_chr %in% names(data))){
    #stop(glue::glue("{var1_chr} not in data set."))
    usethis::ui_stop("{var1_chr} is not in the data set.")
  }

  # alert user if variable not in data set ----
  if (!(var2_chr %in% names(data))){
    #stop(glue::glue("{var2_chr} not in data set."))
    usethis::ui_stop("{var2_chr} is not in the data set.")
  }
```


Add to test

```{r, eval = FALSE}
test_that("length", {
  # evaluate correctness of output produced ----
  expected <- compute_corr(data = faithful, var1 = eruptions, var2 = waiting)
  expect_s3_class(expected, "data.frame")
  expect_equal(dim(expected), c(1,2))
  expect_named(expected, c("correlation", "pval"))
  expect_equal(expected[["correlation"]], 0.901, tolerance = 0.001)
  # catching errors ----
  expect_error(compute_corr(data = faithful, var1 = erruptions, var2 = waiting))
})

```




# Challenge function

* Can we break this up to make it easier to test?

* What type of object should the function output?

* What type of object does this function expect, can we put up guardrails so the user doesn't send the wrong thing? How do we test those guardrails?

## original

```{r}
awesome_rladies <- function(v) {
  
  sapply(v, function(x) {
    if (x == 1) {
      verb <- "is"
      noun <- "RLady"
    }
    
    if (x > 1) {
      verb <- "are"
      noun <- "RLadies"
    }
    
    as.character(glue::glue("There {verb} {x} awesome {noun}!"))
  })
}
```


## broken up

```{r, eval = FALSE}
write_rladies <- function(x){
  if (x == 1) {
    verb <- "is"
    noun <- "RLady"
  } 
  
  if(x > 1) {
    verb <- "are"
    noun <- "RLadies"
  }
  
  as.character(glue::glue("There {verb} {x} awesome {noun}!"))
}




compose_rladies <- function(x){
  #sapply(x, write_rladies)
  purrr::map_chr(x, write_rladies)
}
```


 `usethis::use_test()` to create a second test file, right?
 
## tests


what to name test?

```{r}
test_that("length", {
  # evaluate output produced ----
  expected <- write_rladies(1)
  expect_s3_class(expected, "character")
})

```


add to function

```{r, eval = FALSE}
write_rladies <- function(x){
  
 if ( !(is.numeric(x) & (x > 0)) ){
    usethis::ui_stop("Input must be numeric and greater than 0.")
  }

  
  if (x == 1) {
    verb <- "is"
    noun <- "RLady"
  } 
  
  if(x > 1) {
    verb <- "are"
    noun <- "RLadies"
  }
  
  glue::glue("There {verb} {x} awesome {noun}!")
}
```

add to test, need to work through this more


```{r}
usethis::use_test("rladies")


test_that("correct", {
  # evaluate output produced ----
  expected_1 <- write_rladies(1)
  expected_2 <- write_rladies(2)
  expect_equal(expected_1, "There is 1 awesome RLady!")
  expect_equal(expected_2, "There are 2 awesome RLadies!")
  # ----
  expected_multiple <- compose_rladies(1:2)
  expect_length(expected_multiple, 2)
})

```

