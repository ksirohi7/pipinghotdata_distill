---
title: "sunburst"
description: |
  description
base_url: https://www.pipinghotdata.com/
preview: 
twitter:
  site: "@PipingHotData"
  creator: "@PipingHotData"
date: 04-03-2021
author:
  - name: Shannon Pileggi
output:
  distill::distill_article:
    toc: true
    toc_depth: 1
    self_contained: false
draft: false
creative_commons: CC BY
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# TL; DR



# The data

tidytuesday salary data

# Libraries

```{r}
library(tidyverse)
library(pals)
```

# Data processing


```{r}
survey_raw <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-05-18/survey.csv')
```


```{r}
survey_summary <- survey_raw %>% 
  # identify top industries
  group_by(industry) %>% 
  mutate(
    # number of respondents per industry
    n_industry = n()
  ) %>%
  ungroup() %>% 
  arrange(desc(n_industry), industry) %>%
  mutate(
    # rank of industry in terms of number of survey respondents
    n_industry_rank = as.numeric(factor(-n_industry)),
    # very light cleaning of job title
    job_title = tolower(job_title) %>% 
      str_remove_all("[:digit:]+") %>% 
      str_trim() %>% 
      ifelse(. == "rn", "registered nurse", .)
  ) %>% 
  filter(n_industry_rank %in% 1:6) %>% 
  # identify top 6 job titles in each industry 
  group_by(n_industry_rank, n_industry, industry, job_title) %>%
  summarize(
    # number of titles within industry
    n_title = n(),
    # median salary per title
    median_salary = median(annual_salary)
  ) %>% 
  ungroup() %>% 
  arrange(n_industry_rank, industry, desc(n_title)) %>% 
  group_by(industry) %>% 
  # keep top 6 job titles within industry
  slice(1:6) %>%
  # recompute number of respondents per industry based on titles selected
  mutate(n_industry = sum(n_title)) %>% 
  ungroup() %>% 
  mutate(
    # relative scale of salary for plotting
    median_salary_scaled = median_salary / max(median_salary) * 100,
    # base n respondents
    n_total = sum(n_title),
    # percent of respondents per title
    pct_title = n_title / n_total * 100,
    pct_industry = n_industry / n_total * 100
  ) %>% 
  arrange(desc(n_industry, n_title))
```




```{r}
colors_industry <- pals::cubicyf(n = 6) %>% 
  set_names(unique(survey_summary[["industry"]]))
```






https://learnr.wordpress.com/2009/03/29/ggplot2-variable-width-column-chart/

```{r}
survey_burst <- survey_summary %>% 
  # join colors to data frame ----
    left_join(enframe(colors_industry, name = "industry", value = "color_industry"), 
            by = "industry") %>%
  # arrange descending industry but ascending title
  # to compute title colors
  arrange(desc(n_industry), industry, n_title, title_unique) %>% 
  group_by(industry) %>% 
  mutate(
    # enumerate title in industry ----
    id_title = row_number(),
    # number of titles per industry ----
    num_title = max(id_title)
  ) %>% 
  ungroup() %>% 
  mutate(
    # degree of transparency based on number of attributes ----
    color_trans = id_title / num_title ,
    color_title = map2_chr(color_industry, color_trans, ~ adjustcolor(.x, .y))
  ) %>% 
  # this arrange specifies the ordering of the figure
  # clockwise ---
  arrange(-pct_industry, industry, -pct_title, title_unique) %>%
  # counter clockwise ---
  # arrange(pct_industry, industry, pct_title, title_unique) %>% 
  mutate(
    industry = fct_inorder(industry),
    title_unique = fct_inorder(title_unique)
  ) %>% 
  group_by(industry) %>% 
  mutate(cum_title_pct = cumsum(pct_title)) %>% 
  ungroup() %>% 
  mutate(
    cum_industry_pct = cumsum(cum_title_pct),
    cum_all = cumsum(pct_title)
  ) %>% 
  mutate(
    # compute coordinates of the rectangles ----
    # the 0.0003 is an adjustment on the 0 to 1 scales to add a small
    # amount of white space between rectangles
    rect_x_max = cumsum(pct_title) - 0.003,      # xmax ----
    rect_x_min = rect_x_max - pct_title + 0.003, # xmin ----
    rect_x_mid = (rect_x_min + rect_x_max)/2      # xmid ----
  ) 

```




```{r}
colors_title <- volcano_burst[["color_title"]]
names(colors_title) <- volcano_burst[["title_unique"]]

all_colors <- c(colors_industry, colors_title)
```



```{r}
# create an inner ring for industrys ----
layer_industry <- volcano_burst %>% 
  dplyr::select(industry, pct_industry, rect_x_max, rect_x_min) %>% 
  # first, get stopping point for each rectangle ----
  arrange(industry, desc(rect_x_max)) %>% 
  group_by(industry) %>%
  # keep one entry per industry ----
  slice(1) %>% 
  ungroup() %>% 
  dplyr::select(industry, pct_industry, stop = rect_x_max) %>% 
  # second, get starting point for each rectangle ----
  left_join(
    volcano_burst %>% 
      dplyr::select(industry, pct_industry, rect_x_max, rect_x_min) %>% 
      arrange(industry, rect_x_max) %>% 
      group_by(industry) %>% 
      slice(1) %>% 
      ungroup() %>% 
      dplyr::select(industry, pct_industry, start = rect_x_min),
    by = c("industry", "pct_industry")
  ) %>% 
  # insert blank row for extra white space where circle starts/stops ---
  bind_rows(
    tibble(
      attr_category = NA, 
      start = 0.98433, 
      stop = 1.001)
  ) %>% 
  mutate(
    # compute midpoint for labeling if needed ----
    mid = (stop - start)/2 + start,
    # a label for industry pct ----
    industry_pct = ifelse(is.na(industry), NA, glue::glue('{scales::percent(pct_industry, accuracy = 1)}'))
  )

```




```{r}
volcano_burst %>% 
  # width = level_2, height = box_pct ----
ggplot(aes(
  ymin = 36,
  ymax = 80, 
  xmin = rect_x_min, 
  xmax = rect_x_max,
  fill = title_unique
 )) +
  geom_rect(show.legend = FALSE) +
  coord_polar() +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(), 
    axis.text.y = element_blank(),
    panel.grid = element_blank(),
    legend.position = "none",
  ) +
  ylim(-25, 122) +
  scale_fill_manual(values = all_colors) +
  geom_rect(
    data = layer_industry,
    aes(
      ymin = 0,
      ymax = 35, 
      xmin = start, 
      xmax = stop,
      fill = industry
    )
  ) 
```



